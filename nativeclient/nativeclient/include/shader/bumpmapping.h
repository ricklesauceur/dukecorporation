#include <string>

namespace Natorium
{

const std::string strBumpMappingVertex(
	"#version 330\n"
	"\n"
	"\n"
	"uniform mat4 projection;\n"
	"uniform mat4 view;\n"
	"uniform mat4 model;\n"
	"\n"
	"\n"
	"\n"
	"layout(location = 0) in vec4 position;\n"
	"layout(location = 1) in vec4 color;\n"
	"layout(location = 2) in vec2 texCoord;\n"
	"\n"
	"smooth out vec4 fragmentColor;\n"
	"smooth out vec2 baseTexCoord;\n"
	"\n"
	"void main()\n"
	"{\n"
	"	gl_Position = projection * view * model * position;\n"
	/*"	gl_Position = position;\n"*/
	"\n"
	"	fragmentColor = color;\n"
	"	baseTexCoord = texCoord;\n"
	"}\n"
);

const std::string strBumpMappingFragment(
	"#version 330\n"
	"\n"
	"\n"
	"smooth in vec2 baseTexCoord;\n"
	"smooth in vec4 fragmentColor;\n"
	"uniform sampler2D baseTexture;\n"
	"uniform sampler2D normalTexture;\n"
	"\n"
	"\n"
	"out vec4 outputColor;\n"
	"\n"
	"\n"
	"void main()\n"
	"{\n"
	"//sample color & normals from our textures \n"
	"vec4 color = texture2D(baseTexture, baseTexCoord); \n"
	"vec3 nColor = texture2D(normalTexture, baseTexCoord).rgb; \n"
	"\n"
	"\n"
	"vec2 resolution = vec2(1024.0, 768.0); \n"
	"vec3 light = vec3(0.0, 0.0, 0.125); \n"
	"vec4 lightColor = vec4(1.0, 1.0, 1.0, 1.0); \n"
	"vec4 ambientColor = vec4(1.0, 1.0, 0.55, 1.0); \n"
	"float ambientIntensity = 1.0; \n"
	"//some bump map programs will need the Y value flipped.. \n"
	"nColor.g = 1.0 - nColor.g; \n"
	"\n"
	"\n"
	"\n"
	"//normals need to be converted to [-1.0, 1.0] range and normalized \n"
	"vec3 normal = normalize(nColor * 2.0 - 1.0); \n"
	"\n"
	"//here we do a simple distance calculation \n"
	"vec3 deltaPos = vec3( (light.xy -  gl_FragCoord.xy) / resolution.xy, light.z ); \n"
	"\n"
	" vec3 lightDir = normalize(deltaPos); \n"
	"float lambert = clamp(dot(normal, lightDir), 0.0, 1.0); \n"
	"\n"   
	"    //now let's get a nice little falloff \n"
	"float d = sqrt(dot(deltaPos, deltaPos)); \n"
	"//float att = useShadow ? 1.0 / ( attenuation.x + (attenuation.y*d) + (attenuation.z*d*d) ) : 1.0; \n"
	"float att = 1.0; \n"
	"\n"   
	"//vec3 result = vec3(0.0, 0.0, 0.0); \n"
	"vec3 result = ((ambientIntensity * ambientColor.rgb) + (att * lambert * lightColor.rgb)) * color.rgb; \n"
	"\n"   
	"outputColor = vec4(result.xyz, color.a) * fragmentColor; \n"
	"}\n"
);

}